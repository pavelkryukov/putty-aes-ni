From 6cc5255ab861890dbff56883f8d63af099b4a036 Mon Sep 17 00:00:00 2001
From: "Pavel I. Kryukov" <kryukov@frtk.ru>
Date: Sat, 14 Oct 2017 12:47:59 +0300
Subject: [PATCH 05/12] Move AES-NI code to the bottom of file

This is required to prevent generating SSE2 code for SW AES
and for the better readability of the changes
---
 sshaes.c | 1278 +++++++++++++++++++++++++++++++-------------------------------
 1 file changed, 641 insertions(+), 637 deletions(-)

diff --git a/sshaes.c b/sshaes.c
index a347d9a..7b42de8 100644
--- a/sshaes.c
+++ b/sshaes.c
@@ -1,7 +1,5 @@
 /**
- * sshaes.c
- *
- * aes.c - implementation of AES / Rijndael
+ * sshaes.c - implementation of AES / Rijndael
  * 
  * AES is a flexible algorithm as regards endianness: it has no
  * inherent preference as to which way round you should form words
@@ -27,37 +25,17 @@
  * GET_32BIT_LSB_FIRST for GET_32BIT_MSB_FIRST, I could create an
  * implementation that worked internally little-endian and gave the
  * same answers at the same speed.
- *
- * Implementation of AES for PuTTY using AES-NI
- * instuction set expansion was made by:
- * @author Pavel Kryukov <kryukov@frtk.ru>
- * @author Maxim Kuznetsov <maks.kuznetsov@gmail.com>
- * @author Svyatoslav Kuzmich <svatoslav1@gmail.com>
- *
- * For Putty AES NI project
- * http://putty-aes-ni.googlecode.com/
  */
 
-/*
- * Check of compiler version
- */
-#ifdef _FORCE_AES_NI
-#   define COMPILER_SUPPORTS_AES_NI
-#elif defined(__GNUC__)
-#    ifdef __AES__
-#       pragma GCC target("aes")
-#       pragma GCC target("sse4.1")
-#       define COMPILER_SUPPORTS_AES_NI
-#    endif
-#elif defined (_MSC_VER)
-#   if (defined(_M_X64) || defined(_M_IX86)) && _MSC_FULL_VER >= 150030729
-#      define COMPILER_SUPPORTS_AES_NI
-#   endif
-#endif
+#include <assert.h>
+#include <stdlib.h>
 
-#ifdef _FORCE_SOFTWARE_AES
-#   undef COMPILER_SUPPORTS_AES_NI
-#endif
+#include "ssh.h"
+
+#define MAX_NR 14		       /* max no of rounds */
+#define NB 4                          /* no of words in cipher blk */
+
+#define mulby2(x) ( ((x&0x7F) << 1) ^ (x & 0x80 ? 0x1B : 0) )
 
 /*
  * Inline specificator
@@ -70,25 +48,6 @@
 #    defile INLINE
 #endif
 
-/*
- * Include section
- */
-#include <assert.h>
-#include <stdlib.h>
-
-#ifdef COMPILER_SUPPORTS_AES_NI
-#  include <wmmintrin.h>
-#  include <smmintrin.h>
-#endif
-
-#include "ssh.h"
-
-#define MAX_NR 14   /* max no of rounds */
-#define NB 4        /* no of words in cipher blk */
-
-/*
- * Pseudo-class AESContext
- */
 typedef struct AESContext AESContext;
 
 struct AESContext {
@@ -107,11 +66,8 @@ static void aes_encrypt_cbc_sw(unsigned char*, int, AESContext*);
 static void aes_decrypt_cbc_sw(unsigned char*, int, AESContext*);
 static void aes_sdctr_sw(unsigned char*, int, AESContext*);
 
-#ifdef COMPILER_SUPPORTS_AES_NI
-static void aes_encrypt_cbc_ni(unsigned char*, int, AESContext*);
-static void aes_decrypt_cbc_ni(unsigned char*, int, AESContext*);
-static void aes_sdctr_ni(unsigned char*, int, AESContext*);
-#endif
+INLINE static int supports_aes_ni();
+static void aes_setup_ni(AESContext * ctx, unsigned char *key, int keylen);
 
 INLINE static void aes_encrypt_cbc(unsigned char *blk, int len, AESContext * ctx)
 {
@@ -129,326 +85,77 @@ INLINE static void aes_sdctr(unsigned char *blk, int len, AESContext * ctx)
 }
 
 /*
- * Determinators of CPU type
- */
-#if defined(__GNUC__) && defined(COMPILER_SUPPORTS_AES_NI)
-INLINE static void __cpuid(unsigned int* CPUInfo, int func)
-{
-    __asm__ __volatile__
-    (
-        "cpuid"
-        : "=a" (CPUInfo[0])
-        , "=b" (CPUInfo[1])
-        , "=c" (CPUInfo[2])
-        , "=d" (CPUInfo[3])
-        : "a"  (func)
-    );
-}
-#endif
-
-INLINE static int supports_aes_ni()
-{
-#ifndef COMPILER_SUPPORTS_AES_NI
-    return 0;
-#else
-    unsigned int CPUInfo[4];
-    __cpuid(CPUInfo, 1);
-    return CPUInfo[2] & (1 << 25);
-#endif
-}
-
-/*
- * Wrapper of SHUFPD instruction for MSVC
- */
-#ifdef COMPILER_SUPPORTS_AES_NI
-#ifdef _MSC_VER
-INLINE static __m128i mm_shuffle_pd_i0(__m128i a, __m128i b)
-{
-    union {
-        __m128i i;
-        __m128d d;
-    } au, bu, ru;
-    au.i = a;
-    bu.i = b;
-    ru.d = _mm_shuffle_pd(au.d, bu.d, 0);
-    return ru.i;
-}
-
-INLINE static __m128i mm_shuffle_pd_i1(__m128i a, __m128i b)
-{
-    union {
-        __m128i i;
-        __m128d d;
-    } au, bu, ru;
-    au.i = a;
-    bu.i = b;
-    ru.d = _mm_shuffle_pd(au.d, bu.d, 1);
-    return ru.i;
-}
-#else
-#define mm_shuffle_pd_i0(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 0));
-#define mm_shuffle_pd_i1(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 1));
-#endif
-#endif
-
-/*
- * AES-NI key expansion assist functions
+ * SW AES lookup tables
  */
-#ifdef COMPILER_SUPPORTS_AES_NI
-INLINE static __m128i AES_128_ASSIST (__m128i temp1, __m128i temp2)
-{
-    __m128i temp3;
-    temp2 = _mm_shuffle_epi32 (temp2 ,0xff);
-    temp3 = _mm_slli_si128 (temp1, 0x4);
-    temp1 = _mm_xor_si128 (temp1, temp3);
-    temp3 = _mm_slli_si128 (temp3, 0x4);
-    temp1 = _mm_xor_si128 (temp1, temp3);
-    temp3 = _mm_slli_si128 (temp3, 0x4);
-    temp1 = _mm_xor_si128 (temp1, temp3);
-    temp1 = _mm_xor_si128 (temp1, temp2);
-    return temp1;
-}
-
-INLINE static void KEY_192_ASSIST(__m128i* temp1, __m128i * temp2, __m128i * temp3)
-{
-    __m128i temp4;
-    *temp2 = _mm_shuffle_epi32 (*temp2, 0x55);
-    temp4 = _mm_slli_si128 (*temp1, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    *temp1 = _mm_xor_si128 (*temp1, *temp2);
-    *temp2 = _mm_shuffle_epi32(*temp1, 0xff);
-    temp4 = _mm_slli_si128 (*temp3, 0x4);
-    *temp3 = _mm_xor_si128 (*temp3, temp4);
-    *temp3 = _mm_xor_si128 (*temp3, *temp2);
-}
-
-INLINE static void KEY_256_ASSIST_1(__m128i* temp1, __m128i * temp2)
-{
-    __m128i temp4;
-    *temp2 = _mm_shuffle_epi32(*temp2, 0xff);
-    temp4 = _mm_slli_si128 (*temp1, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp1 = _mm_xor_si128 (*temp1, temp4);
-    *temp1 = _mm_xor_si128 (*temp1, *temp2);
-}
+static const unsigned char Sbox[256] = {
+    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+};
 
-INLINE static void KEY_256_ASSIST_2(__m128i* temp1, __m128i * temp3)
-{
-    __m128i temp2,temp4;
-    temp4 = _mm_aeskeygenassist_si128 (*temp1, 0x0);
-    temp2 = _mm_shuffle_epi32(temp4, 0xaa);
-    temp4 = _mm_slli_si128 (*temp3, 0x4);
-    *temp3 = _mm_xor_si128 (*temp3, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp3 = _mm_xor_si128 (*temp3, temp4);
-    temp4 = _mm_slli_si128 (temp4, 0x4);
-    *temp3 = _mm_xor_si128 (*temp3, temp4);
-    *temp3 = _mm_xor_si128 (*temp3, temp2);
-}
-
-/*
- * AES-NI key expansion core
- */
-static void AES_128_Key_Expansion (unsigned char *userkey, __m128i *key)
-{
-    __m128i temp1, temp2;
-    temp1 = _mm_loadu_si128((__m128i*)userkey);
-    key[0] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1 ,0x1);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[1] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x2);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[2] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x4);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[3] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x8);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[4] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x10);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[5] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x20);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[6] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x40);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[7] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x80);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[8] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x1b);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[9] = temp1;
-    temp2 = _mm_aeskeygenassist_si128 (temp1,0x36);
-    temp1 = AES_128_ASSIST(temp1, temp2);
-    key[10] = temp1;
-}
-
-static void AES_192_Key_Expansion (unsigned char *userkey, __m128i *key)
-{
-    __m128i temp1, temp2, temp3;
-    temp1 = _mm_loadu_si128((__m128i*)userkey);
-    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
-    key[0]=temp1;
-    key[1]=temp3;
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x1);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[1] = mm_shuffle_pd_i0(key[1], temp1);
-    key[2] = mm_shuffle_pd_i1(temp1, temp3);
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x2);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[3]=temp1;
-    key[4]=temp3;
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x4);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[4] = mm_shuffle_pd_i0(key[4], temp1);
-    key[5] = mm_shuffle_pd_i1(temp1, temp3);
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x8);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[6]=temp1;
-    key[7]=temp3;
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x10);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[7] = mm_shuffle_pd_i0(key[7], temp1);
-    key[8] = mm_shuffle_pd_i1(temp1, temp3);
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x20);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[9]=temp1;
-    key[10]=temp3;
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x40);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[10] = mm_shuffle_pd_i0(key[10], temp1);
-    key[11] = mm_shuffle_pd_i1(temp1, temp3);
-    temp2=_mm_aeskeygenassist_si128 (temp3,0x80);
-    KEY_192_ASSIST(&temp1, &temp2, &temp3);
-    key[12]=temp1;
-    key[13]=temp3;
-}
-
-static void AES_256_Key_Expansion (unsigned char *userkey, __m128i *key)
-{
-    __m128i temp1, temp2, temp3;
-    temp1 = _mm_loadu_si128((__m128i*)userkey);
-    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
-    key[0] = temp1;
-    key[1] = temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x01);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[2]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[3]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x02);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[4]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[5]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x04);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[6]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[7]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x08);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[8]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[9]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x10);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[10]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[11]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x20);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[12]=temp1;
-    KEY_256_ASSIST_2(&temp1, &temp3);
-    key[13]=temp3;
-    temp2 = _mm_aeskeygenassist_si128 (temp3,0x40);
-    KEY_256_ASSIST_1(&temp1, &temp2);
-    key[14]=temp1;
-}
-#endif /* COMPILER_SUPPORTS_AES_NI */
-
-/*
- * SW AES lookup tables
- */
-static const unsigned char Sbox[256] = {
-    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
-    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
-    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
-    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
-    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
-    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
-    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
-    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
-    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
-    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
-    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
-    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
-    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
-    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
-    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
-    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
-    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
-    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
-    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
-    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
-    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
-    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
-    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
-    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
-    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
-    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
-    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
-    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
-    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
-    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
-    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
-    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
-};
-
-static const unsigned char Sboxinv[256] = {
-    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
-    0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
-    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
-    0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
-    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
-    0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
-    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
-    0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
-    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
-    0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
-    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
-    0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
-    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
-    0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
-    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
-    0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
-    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
-    0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
-    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
-    0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
-    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
-    0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
-    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
-    0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
-    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
-    0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
-    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
-    0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
-    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
-    0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
-    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
-    0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
-};
+static const unsigned char Sboxinv[256] = {
+    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
+    0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
+    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
+    0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
+    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
+    0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
+    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
+    0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
+    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
+    0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
+    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
+    0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
+    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
+    0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
+    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
+    0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
+    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
+    0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
+    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
+    0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
+    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
+    0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
+    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
+    0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
+    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
+    0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
+    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
+    0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
+    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
+    0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
+    0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
+};
 
 static const word32 E0[256] = {
     0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d,
@@ -980,11 +687,6 @@ static const word32 D3[256] = {
 };
 
 /*
- * Software AES key expansion macros
- */
-#define mulby2(x) ( ((x&0x7F) << 1) ^ (x & 0x80 ? 0x1B : 0) )
-
-/*
  * Set up an AESContext. `keylen' is measured in
  * bytes; it can be either 16 (128-bit), 24 (192-bit), or 32
  * (256-bit).
@@ -997,62 +699,7 @@ static void aes_setup(AESContext * ctx, unsigned char *key, int keylen)
 
     if (ctx->isNI)
     {
-#ifdef COMPILER_SUPPORTS_AES_NI
-        __m128i *keysched, *invkeysched;
-        keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
-        invkeysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
-
-        ctx->encrypt = &aes_encrypt_cbc_ni;
-        ctx->decrypt = &aes_decrypt_cbc_ni;
-        ctx->sdctr = &aes_sdctr_ni;
-
-        /*
-         * Now do the key setup itself.
-         */
-        switch (keylen)
-        {
-        case 16:
-            AES_128_Key_Expansion (key, keysched);
-            break;
-        case 24:
-            AES_192_Key_Expansion (key, keysched);
-            break;
-        case 32:
-            AES_256_Key_Expansion (key, keysched);
-            break;
-        default:
-            assert(0);
-        }
-
-        /*
-         * Now prepare the modified keys for the inverse cipher.
-         */
-        invkeysched += ctx->Nr;
-        *invkeysched = *keysched;
-        switch (ctx->Nr)
-        {
-        case 14:
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-        case 12:
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-        case 10:
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
-        default:
-            *(--invkeysched) = *(++keysched);
-        }
-#else
-        assert(0);
-#endif /* COMPILER_SUPPORTS_AES_NI */
+        aes_setup_ni(ctx, key, keylen);
     }
     else {
         int i, j, Nk, rconst;
@@ -1125,214 +772,36 @@ static void aes_setup(AESContext * ctx, unsigned char *key, int keylen)
     }
 }
 
-#ifdef COMPILER_SUPPORTS_AES_NI
 /*
- * AES-NI encrypt/dectypt core
+ * Software encrypt/decrypt macros
  */
-static void aes_encrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
-{
-    __m128i enc;
-    __m128i* block = (__m128i*)blk;
-    const __m128i* finish = (__m128i*)(blk + len);
+#define ADD_ROUND_KEY (block[0]^=*keysched++,\
+                       block[1]^=*keysched++,\
+                       block[2]^=*keysched++,\
+                       block[3]^=*keysched++)
+#define MOVEWORD(i) ( block[i] = newstate[i] )
 
-    assert((len & 15) == 0);
+#define ENCWORD(i) ( newstate[i] = (E0[(block[i      ] >> 24) & 0xFF] ^ \
+                                    E1[(block[(i+1)&3] >> 16) & 0xFF] ^ \
+                                    E2[(block[(i+2)&3] >>  8) & 0xFF] ^ \
+                                    E3[ block[(i+3)&3]        & 0xFF]) )
+#define ENCROUND { ENCWORD(0); ENCWORD(1); ENCWORD(2); ENCWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
 
-    /* Load IV */
-    enc = _mm_loadu_si128((__m128i*)(ctx->iv));
-    while (block < finish)
-    {
-        /* Key schedule ptr   */
-        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
+#define ENCLASTWORD(i) ( newstate[i] = \
+                            (Sbox[(block[i]       >> 24) & 0xFF] << 24) | \
+                            (Sbox[(block[(i+1)&3] >> 16) & 0xFF] << 16) | \
+                            (Sbox[(block[(i+2)&3] >>  8) & 0xFF] <<  8) | \
+                            (Sbox[(block[(i+3)&3]      ) & 0xFF]      ) )
+#define ENCLASTROUND { ENCLASTWORD(0); ENCLASTWORD(1); ENCLASTWORD(2); ENCLASTWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
 
-        /* Xor data with IV */
-        enc  = _mm_xor_si128(_mm_loadu_si128(block), enc);
-
-        /* Perform rounds */
-        enc  = _mm_xor_si128(enc, *keysched);
-        switch (ctx->Nr)
-        {
-        case 14:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-        case 12:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-        case 10:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenclast_si128(enc, *(++keysched));
-            break;
-        default:
-            assert(0);
-        }
-
-        /* Store and go to next block */
-        _mm_storeu_si128(block, enc);
-        ++block;
-    }
-
-    /* Update IV */
-    _mm_storeu_si128((__m128i*)(ctx->iv), enc);
-}
-
-static void aes_decrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
-{
-    __m128i dec = _mm_setzero_si128();
-    __m128i last, iv;
-    __m128i* block = (__m128i*)blk;
-    const __m128i* finish = (__m128i*)(blk + len);
-
-    assert((len & 15) == 0);
-
-    /* Load IV */
-    iv = _mm_loadu_si128((__m128i*)(ctx->iv));
-    while (block < finish)
-    {
-        /* Key schedule ptr   */
-        __m128i* keysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
-        last = _mm_loadu_si128(block);
-        dec  = _mm_xor_si128(last, *keysched);
-        switch (ctx->Nr)
-        {
-        case 14:
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-        case 12:
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-        case 10:
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdec_si128(dec, *(++keysched));
-            dec = _mm_aesdeclast_si128(dec, *(++keysched));
-            break;
-        default:
-            assert(0);
-        }
-
-        /* Xor data with IV */
-        dec  = _mm_xor_si128(iv, dec);
-
-        /* Store data */
-        _mm_storeu_si128(block, dec);
-        iv = last;
-
-        /* Go to next block */
-        ++block;
-    }
-
-    /* Update IV */
-    _mm_storeu_si128((__m128i*)(ctx->iv), dec);
-}
-
-static void aes_sdctr_ni(unsigned char *blk, int len, AESContext *ctx)
-{
-    const __m128i BSWAP_EPI64 = _mm_setr_epi8(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12);
-    const __m128i ONE  = _mm_setr_epi32(0,0,0,1);
-    const __m128i ZERO = _mm_setzero_si128();
-    __m128i iv;
-    __m128i* block = (__m128i*)blk;
-    const __m128i* finish = (__m128i*)(blk + len);
-
-    assert((len & 15) == 0);
-
-    iv = _mm_loadu_si128((__m128i*)ctx->iv);
-
-    while (block < finish)
-    {
-        __m128i enc;
-        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);/* Key schedule ptr   */
-
-        /* Perform rounds */
-        enc  = _mm_xor_si128(iv, *keysched); /* Note that we use IV */
-        switch (ctx->Nr)
-        {
-        case 14:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-        case 12:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-        case 10:
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenc_si128(enc, *(++keysched));
-            enc = _mm_aesenclast_si128(enc, *(++keysched));
-            break;
-        default:
-            assert(0);
-        }
-
-        /* Xor with block and store result */
-        enc = _mm_xor_si128(enc, _mm_loadu_si128(block));
-        _mm_storeu_si128(block, enc);
-
-        /* Increment of IV */
-        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap endianess     */
-        iv  = _mm_add_epi64(iv, ONE);            /* Inc low part       */
-        enc = _mm_cmpeq_epi64(iv, ZERO);         /* Check for carry    */
-        enc = _mm_unpacklo_epi64(ZERO, enc);     /* Pack carry reg     */
-        iv  = _mm_sub_epi64(iv, enc);            /* Sub carry reg      */
-        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap enianess back */
-
-        /* Go to next block */
-        ++block;
-    }
-
-    /* Update IV */
-    _mm_storeu_si128((__m128i*)ctx->iv, iv);
-}
-#endif /* COMPILER_SUPPORTS_AES_NI */
-
-/*
- * Software encrypt/decrypt macros
- */
-#define ADD_ROUND_KEY (block[0]^=*keysched++,\
-                       block[1]^=*keysched++,\
-                       block[2]^=*keysched++,\
-                       block[3]^=*keysched++)
-#define MOVEWORD(i) ( block[i] = newstate[i] )
-
-#define ENCWORD(i) ( newstate[i] = (E0[(block[i      ] >> 24) & 0xFF] ^ \
-                                    E1[(block[(i+1)&3] >> 16) & 0xFF] ^ \
-                                    E2[(block[(i+2)&3] >>  8) & 0xFF] ^ \
-                                    E3[ block[(i+3)&3]        & 0xFF]) )
-#define ENCROUND { ENCWORD(0); ENCWORD(1); ENCWORD(2); ENCWORD(3); \
-                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
-
-#define ENCLASTWORD(i) ( newstate[i] = \
-                            (Sbox[(block[i]       >> 24) & 0xFF] << 24) | \
-                            (Sbox[(block[(i+1)&3] >> 16) & 0xFF] << 16) | \
-                            (Sbox[(block[(i+2)&3] >>  8) & 0xFF] <<  8) | \
-                            (Sbox[(block[(i+3)&3]      ) & 0xFF]      ) )
-#define ENCLASTROUND { ENCLASTWORD(0); ENCLASTWORD(1); ENCLASTWORD(2); ENCLASTWORD(3); \
-                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
-
-#define DECWORD(i) ( newstate[i] =  (D0[(block[i]       >> 24) & 0xFF] ^ \
-                                     D1[(block[(i+3)&3] >> 16) & 0xFF] ^ \
-                                     D2[(block[(i+2)&3] >> 8)  & 0xFF] ^ \
-                                     D3[ block[(i+1)&3]        & 0xFF]) )
-#define DECROUND { DECWORD(0); DECWORD(1); DECWORD(2); DECWORD(3); \
-                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
+#define DECWORD(i) ( newstate[i] =  (D0[(block[i]       >> 24) & 0xFF] ^ \
+                                     D1[(block[(i+3)&3] >> 16) & 0xFF] ^ \
+                                     D2[(block[(i+2)&3] >> 8)  & 0xFF] ^ \
+                                     D3[ block[(i+1)&3]        & 0xFF]) )
+#define DECROUND { DECWORD(0); DECWORD(1); DECWORD(2); DECWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
 
 #define DECLASTWORD(i) (newstate[i] = \
                            (Sboxinv[(block[i]       >> 24) & 0xFF] << 24) | \
@@ -1639,3 +1108,538 @@ const struct ssh2_ciphers ssh2_aes = {
     sizeof(aes_list) / sizeof(*aes_list),
     aes_list
 };
+
+/*
+ * Implementation of AES for PuTTY using AES-NI
+ * instuction set expansion was made by:
+ * @author Pavel Kryukov <kryukov@frtk.ru>
+ * @author Maxim Kuznetsov <maks.kuznetsov@gmail.com>
+ * @author Svyatoslav Kuzmich <svatoslav1@gmail.com>
+ *
+ * For Putty AES NI project
+ * http://pavelkryukov.github.io/putty-aes-ni/
+ */
+
+/*
+ * Check of compiler version
+ */
+#ifdef _FORCE_AES_NI
+#   define COMPILER_SUPPORTS_AES_NI
+#elif defined(__GNUC__)
+#    ifdef __AES__
+#       define COMPILER_SUPPORTS_AES_NI
+#    endif
+#elif defined (_MSC_VER)
+#   if (defined(_M_X64) || defined(_M_IX86)) && _MSC_FULL_VER >= 150030729
+#      define COMPILER_SUPPORTS_AES_NI
+#   endif
+#endif
+
+#ifdef _FORCE_SOFTWARE_AES
+#   undef COMPILER_SUPPORTS_AES_NI
+#endif
+
+#if defined(COMPILER_SUPPORTS_AES_NI) && defined(__GNUC__)
+#   pragma GCC target("aes")
+#   pragma GCC target("sse4.1")
+#endif
+
+#ifdef COMPILER_SUPPORTS_AES_NI
+#  include <wmmintrin.h>
+#  include <smmintrin.h>
+#endif
+
+/*
+ * Determinators of CPU type
+ */
+#if defined(__GNUC__) && defined(COMPILER_SUPPORTS_AES_NI)
+INLINE static void __cpuid(unsigned int* CPUInfo, int func)
+{
+    __asm__ __volatile__
+    (
+        "cpuid"
+        : "=a" (CPUInfo[0])
+        , "=b" (CPUInfo[1])
+        , "=c" (CPUInfo[2])
+        , "=d" (CPUInfo[3])
+        : "a"  (func)
+    );
+}
+#endif
+
+#ifdef COMPILER_SUPPORTS_AES_NI
+INLINE static int supports_aes_ni()
+{
+    unsigned int CPUInfo[4];
+    __cpuid(CPUInfo, 1);
+    return CPUInfo[2] & (1 << 25);
+}
+
+/*
+ * Wrapper of SHUFPD instruction for MSVC
+ */
+#ifdef _MSC_VER
+INLINE static __m128i mm_shuffle_pd_i0(__m128i a, __m128i b)
+{
+    union {
+        __m128i i;
+        __m128d d;
+    } au, bu, ru;
+    au.i = a;
+    bu.i = b;
+    ru.d = _mm_shuffle_pd(au.d, bu.d, 0);
+    return ru.i;
+}
+
+INLINE static __m128i mm_shuffle_pd_i1(__m128i a, __m128i b)
+{
+    union {
+        __m128i i;
+        __m128d d;
+    } au, bu, ru;
+    au.i = a;
+    bu.i = b;
+    ru.d = _mm_shuffle_pd(au.d, bu.d, 1);
+    return ru.i;
+}
+#else
+#define mm_shuffle_pd_i0(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 0));
+#define mm_shuffle_pd_i1(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 1));
+#endif
+#endif
+
+/*
+ * AES-NI key expansion assist functions
+ */
+#ifdef COMPILER_SUPPORTS_AES_NI
+INLINE static __m128i AES_128_ASSIST (__m128i temp1, __m128i temp2)
+{
+    __m128i temp3;
+    temp2 = _mm_shuffle_epi32 (temp2 ,0xff);
+    temp3 = _mm_slli_si128 (temp1, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp3 = _mm_slli_si128 (temp3, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp3 = _mm_slli_si128 (temp3, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp1 = _mm_xor_si128 (temp1, temp2);
+    return temp1;
+}
+
+INLINE static void KEY_192_ASSIST(__m128i* temp1, __m128i * temp2, __m128i * temp3)
+{
+    __m128i temp4;
+    *temp2 = _mm_shuffle_epi32 (*temp2, 0x55);
+    temp4 = _mm_slli_si128 (*temp1, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    *temp1 = _mm_xor_si128 (*temp1, *temp2);
+    *temp2 = _mm_shuffle_epi32(*temp1, 0xff);
+    temp4 = _mm_slli_si128 (*temp3, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    *temp3 = _mm_xor_si128 (*temp3, *temp2);
+}
+
+INLINE static void KEY_256_ASSIST_1(__m128i* temp1, __m128i * temp2)
+{
+    __m128i temp4;
+    *temp2 = _mm_shuffle_epi32(*temp2, 0xff);
+    temp4 = _mm_slli_si128 (*temp1, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    *temp1 = _mm_xor_si128 (*temp1, *temp2);
+}
+
+INLINE static void KEY_256_ASSIST_2(__m128i* temp1, __m128i * temp3)
+{
+    __m128i temp2,temp4;
+    temp4 = _mm_aeskeygenassist_si128 (*temp1, 0x0);
+    temp2 = _mm_shuffle_epi32(temp4, 0xaa);
+    temp4 = _mm_slli_si128 (*temp3, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    *temp3 = _mm_xor_si128 (*temp3, temp2);
+}
+
+/*
+ * AES-NI key expansion core
+ */
+static void AES_128_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    key[0] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1 ,0x1);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[1] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x2);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[2] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x4);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[3] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x8);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[4] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x10);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[5] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x20);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[6] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x40);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[7] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x80);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[8] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x1b);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[9] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x36);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[10] = temp1;
+}
+
+static void AES_192_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2, temp3;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
+    key[0]=temp1;
+    key[1]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x1);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[1] = mm_shuffle_pd_i0(key[1], temp1);
+    key[2] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x2);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[3]=temp1;
+    key[4]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x4);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[4] = mm_shuffle_pd_i0(key[4], temp1);
+    key[5] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x8);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[6]=temp1;
+    key[7]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x10);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[7] = mm_shuffle_pd_i0(key[7], temp1);
+    key[8] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x20);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[9]=temp1;
+    key[10]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x40);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[10] = mm_shuffle_pd_i0(key[10], temp1);
+    key[11] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x80);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[12]=temp1;
+    key[13]=temp3;
+}
+
+static void AES_256_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2, temp3;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
+    key[0] = temp1;
+    key[1] = temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x01);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[2]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[3]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x02);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[4]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[5]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x04);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[6]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[7]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x08);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[8]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[9]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x10);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[10]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[11]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x20);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[12]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[13]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x40);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[14]=temp1;
+}
+
+/*
+ * AES-NI encrypt/dectypt core
+ */
+static void aes_encrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
+{
+    __m128i enc;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
+
+    assert((len & 15) == 0);
+
+    /* Load IV */
+    enc = _mm_loadu_si128((__m128i*)(ctx->iv));
+    while (block < finish)
+    {
+        /* Key schedule ptr   */
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
+
+        /* Xor data with IV */
+        enc  = _mm_xor_si128(_mm_loadu_si128(block), enc);
+
+        /* Perform rounds */
+        enc  = _mm_xor_si128(enc, *keysched);
+        switch (ctx->Nr)
+        {
+        case 14:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 12:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 10:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenclast_si128(enc, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Store and go to next block */
+        _mm_storeu_si128(block, enc);
+        ++block;
+    }
+
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)(ctx->iv), enc);
+}
+
+static void aes_decrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
+{
+    __m128i dec = _mm_setzero_si128();
+    __m128i last, iv;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
+
+    assert((len & 15) == 0);
+
+    /* Load IV */
+    iv = _mm_loadu_si128((__m128i*)(ctx->iv));
+    while (block < finish)
+    {
+        /* Key schedule ptr   */
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
+        last = _mm_loadu_si128(block);
+        dec  = _mm_xor_si128(last, *keysched);
+        switch (ctx->Nr)
+        {
+        case 14:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+        case 12:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+        case 10:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdeclast_si128(dec, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Xor data with IV */
+        dec  = _mm_xor_si128(iv, dec);
+
+        /* Store data */
+        _mm_storeu_si128(block, dec);
+        iv = last;
+
+        /* Go to next block */
+        ++block;
+    }
+
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)(ctx->iv), dec);
+}
+
+static void aes_sdctr_ni(unsigned char *blk, int len, AESContext *ctx)
+{
+    const __m128i BSWAP_EPI64 = _mm_setr_epi8(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12);
+    const __m128i ONE  = _mm_setr_epi32(0,0,0,1);
+    const __m128i ZERO = _mm_setzero_si128();
+    __m128i iv;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
+
+    assert((len & 15) == 0);
+
+    iv = _mm_loadu_si128((__m128i*)ctx->iv);
+
+    while (block < finish)
+    {
+        __m128i enc;
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);/* Key schedule ptr   */
+
+        /* Perform rounds */
+        enc  = _mm_xor_si128(iv, *keysched); /* Note that we use IV */
+        switch (ctx->Nr)
+        {
+        case 14:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 12:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 10:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenclast_si128(enc, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Xor with block and store result */
+        enc = _mm_xor_si128(enc, _mm_loadu_si128(block));
+        _mm_storeu_si128(block, enc);
+
+        /* Increment of IV */
+        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap endianess     */
+        iv  = _mm_add_epi64(iv, ONE);            /* Inc low part       */
+        enc = _mm_cmpeq_epi64(iv, ZERO);         /* Check for carry    */
+        enc = _mm_unpacklo_epi64(ZERO, enc);     /* Pack carry reg     */
+        iv  = _mm_sub_epi64(iv, enc);            /* Sub carry reg      */
+        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap enianess back */
+
+        /* Go to next block */
+        ++block;
+    }
+
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)ctx->iv, iv);
+}
+
+/*
+ * Set up an AESContext. `keylen' is measured in
+ * bytes; it can be either 16 (128-bit), 24 (192-bit), or 32
+ * (256-bit).
+ */
+static void aes_setup_ni(AESContext * ctx, unsigned char *key, int keylen)
+{
+    __m128i *keysched, *invkeysched;
+    keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
+    invkeysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
+
+    ctx->encrypt = &aes_encrypt_cbc_ni;
+    ctx->decrypt = &aes_decrypt_cbc_ni;
+    ctx->sdctr = &aes_sdctr_ni;
+
+    /*
+     * Now do the key setup itself.
+     */
+    switch (keylen)
+    {
+    case 16:
+        AES_128_Key_Expansion (key, keysched);
+        break;
+    case 24:
+        AES_192_Key_Expansion (key, keysched);
+        break;
+    case 32:
+        AES_256_Key_Expansion (key, keysched);
+        break;
+    default:
+        assert(0);
+    }
+
+    /*
+     * Now prepare the modified keys for the inverse cipher.
+     */
+    invkeysched += ctx->Nr;
+    *invkeysched = *keysched;
+    switch (ctx->Nr)
+    {
+    case 14:
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+    case 12:
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+    case 10:
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+    default:
+        *(--invkeysched) = *(++keysched);
+    }
+}
+
+#else /* COMPILER_SUPPORTS_AES_NI */
+
+static void aes_setup_ni(AESContext * ctx, unsigned char *key, int keylen)
+{
+    assert(0);
+}
+
+INLINE static int supports_aes_ni()
+{
+    return 0;
+}
+
+#endif /* COMPILER_SUPPORTS_AES_NI */
-- 
2.5.3.windows.1

