From b3bb66fa97c2727985638aacbfe2418efbcd2ec4 Mon Sep 17 00:00:00 2001
From: Pavel Kryukov <kryukov@frtk>
Date: Sat, 14 Mar 2015 18:11:19 +0300
Subject: [PATCH 01/12] Support of AES-NI by SSH client

This patch was prepared by three guys:

Pavel Kryukov <kryukov@frtk.ru>
Maxim Kuznetsov <maks.kuznetsov@gmail.com>
Svyatoslav Kuzmich <svatoslav1@gmail.com>

For detailed commit history and contributions, please check
the old repository:

https://github.com/pavelkryukov/putty-aes-ni
---
 sshaes.c | 1211 +++++++++++++++++++++++++++++++++++++++++---------------------
 1 file changed, 804 insertions(+), 407 deletions(-)

diff --git a/sshaes.c b/sshaes.c
index 904cbdb..767948b 100644
--- a/sshaes.c
+++ b/sshaes.c
@@ -1,4 +1,6 @@
-/*
+/**
+ * sshaes.c
+ *
  * aes.c - implementation of AES / Rijndael
  * 
  * AES is a flexible algorithm as regards endianness: it has no
@@ -25,30 +27,357 @@
  * GET_32BIT_LSB_FIRST for GET_32BIT_MSB_FIRST, I could create an
  * implementation that worked internally little-endian and gave the
  * same answers at the same speed.
+ *
+ * Implementation of AES for PuTTY using AES-NI
+ * instuction set expansion was made by:
+ * @author Pavel Kryukov <kryukov@frtk.ru>
+ * @author Maxim Kuznetsov <maks.kuznetsov@gmail.com>
+ * @author Svyatoslav Kuzmich <svatoslav1@gmail.com>
+ *
+ * For Putty AES NI project
+ * http://putty-aes-ni.googlecode.com/
+ */
+
+/*
+ * Check of compiler version
+ */
+#ifdef _FORCE_AES_NI
+#   define COMPILER_SUPPORTS_AES_NI
+#elif defined(__GNUC__)
+#    if (__GNUC__ > 4) || (__GNUC__ == 4 && (__GNUC_MINOR__ >= 4))
+#       define COMPILER_SUPPORTS_AES_NI
+#    endif
+#elif defined (_MSC_VER)
+#   if _MSC_FULL_VER >= 150030729
+#      define COMPILER_SUPPORTS_AES_NI
+#   endif
+#endif
+
+#ifdef _FORCE_SOFTWARE_AES
+#   undef COMPILER_SUPPORTS_AES_NI
+#endif
+
+/*
+ * Inline specificator
  */
+#ifdef __GNUC__
+#    define INLINE __inline__
+#elif defined (_MSC_VER)
+#    define INLINE __forceinline
+#else
+#    defile INLINE
+#endif
 
+/*
+ * Include section
+ */
 #include <assert.h>
 #include <stdlib.h>
 
-#include "ssh.h"
+#ifdef COMPILER_SUPPORTS_AES_NI
+#  include <wmmintrin.h>
+#  include <smmintrin.h>
+#endif
 
-#define MAX_NR 14		       /* max no of rounds */
-#define MAX_NK 8		       /* max no of words in input key */
-#define MAX_NB 8		       /* max no of words in cipher blk */
+#include "ssh.h"
 
-#define mulby2(x) ( ((x&0x7F) << 1) ^ (x & 0x80 ? 0x1B : 0) )
+#define MAX_NR 14   /* max no of rounds */
+#define NB 4        /* no of words in cipher blk */
 
+/*
+ * Pseudo-class AESContext
+ */
 typedef struct AESContext AESContext;
 
 struct AESContext {
-    word32 keysched[(MAX_NR + 1) * MAX_NB];
-    word32 invkeysched[(MAX_NR + 1) * MAX_NB];
-    void (*encrypt) (AESContext * ctx, word32 * block);
-    void (*decrypt) (AESContext * ctx, word32 * block);
-    word32 iv[MAX_NB];
-    int Nb, Nr;
+    word32 keysched[(MAX_NR + 2) * NB];
+    word32 invkeysched[(MAX_NR + 2) * NB];
+    word32 iv[NB];
+    unsigned int Nr; /* number of rounds */
+    unsigned int offset; /* offset for aligned key expansion */
+    void (*encrypt)(unsigned char*, int, AESContext*);
+    void (*decrypt)(unsigned char*, int, AESContext*);
+    void (*sdctr)(unsigned char*, int, AESContext*);
+    int isNI;
 };
 
+static void aes_encrypt_cbc_sw(unsigned char*, int, AESContext*);
+static void aes_decrypt_cbc_sw(unsigned char*, int, AESContext*);
+static void aes_sdctr_sw(unsigned char*, int, AESContext*);
+
+#ifdef COMPILER_SUPPORTS_AES_NI
+static void aes_encrypt_cbc_ni(unsigned char*, int, AESContext*);
+static void aes_decrypt_cbc_ni(unsigned char*, int, AESContext*);
+static void aes_sdctr_ni(unsigned char*, int, AESContext*);
+#endif
+
+INLINE static void aes_encrypt_cbc(unsigned char *blk, int len, AESContext * ctx)
+{
+    ctx->encrypt(blk, len, ctx);
+}
+
+INLINE static void aes_decrypt_cbc(unsigned char *blk, int len, AESContext * ctx)
+{
+    ctx->decrypt(blk, len, ctx);
+}
+
+INLINE static void aes_sdctr(unsigned char *blk, int len, AESContext * ctx)
+{
+    ctx->sdctr(blk, len, ctx);
+}
+
+/*
+ * Determinators of CPU type
+ */
+#if defined(__GNUC__) && defined(COMPILER_SUPPORTS_AES_NI)
+INLINE static void __cpuid(unsigned int* CPUInfo, int func)
+{
+    __asm__ __volatile__
+    (
+        "cpuid"
+        : "=a" (CPUInfo[0])
+        , "=b" (CPUInfo[1])
+        , "=c" (CPUInfo[2])
+        , "=d" (CPUInfo[3])
+        : "a"  (func)
+    );
+}
+#endif
+
+INLINE static int supports_aes_ni()
+{
+#ifndef COMPILER_SUPPORTS_AES_NI
+    return 0;
+#else
+    unsigned int CPUInfo[4];
+    __cpuid(CPUInfo, 1);
+    return CPUInfo[2] & (1 << 25);
+#endif
+}
+
+/*
+ * Wrapper of SHUFPD instruction for MSVC
+ */
+#ifdef COMPILER_SUPPORTS_AES_NI
+#ifdef _MSC_VER
+INLINE static __m128i mm_shuffle_pd_i0(__m128i a, __m128i b)
+{
+    union {
+        __m128i i;
+        __m128d d;
+    } au, bu, ru;
+    au.i = a;
+    bu.i = b;
+    ru.d = _mm_shuffle_pd(au.d, bu.d, 0);
+    return ru.i;
+}
+
+INLINE static __m128i mm_shuffle_pd_i1(__m128i a, __m128i b)
+{
+    union {
+        __m128i i;
+        __m128d d;
+    } au, bu, ru;
+    au.i = a;
+    bu.i = b;
+    ru.d = _mm_shuffle_pd(au.d, bu.d, 1);
+    return ru.i;
+}
+#else
+#define mm_shuffle_pd_i0(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 0));
+#define mm_shuffle_pd_i1(a, b) ((__m128i)_mm_shuffle_pd((__m128d)a, (__m128d)b, 1));
+#endif
+#endif
+
+/*
+ * AES-NI key expansion assist functions
+ */
+#ifdef COMPILER_SUPPORTS_AES_NI
+INLINE static __m128i AES_128_ASSIST (__m128i temp1, __m128i temp2)
+{
+    __m128i temp3;
+    temp2 = _mm_shuffle_epi32 (temp2 ,0xff);
+    temp3 = _mm_slli_si128 (temp1, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp3 = _mm_slli_si128 (temp3, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp3 = _mm_slli_si128 (temp3, 0x4);
+    temp1 = _mm_xor_si128 (temp1, temp3);
+    temp1 = _mm_xor_si128 (temp1, temp2);
+    return temp1;
+}
+
+INLINE static void KEY_192_ASSIST(__m128i* temp1, __m128i * temp2, __m128i * temp3)
+{
+    __m128i temp4;
+    *temp2 = _mm_shuffle_epi32 (*temp2, 0x55);
+    temp4 = _mm_slli_si128 (*temp1, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    *temp1 = _mm_xor_si128 (*temp1, *temp2);
+    *temp2 = _mm_shuffle_epi32(*temp1, 0xff);
+    temp4 = _mm_slli_si128 (*temp3, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    *temp3 = _mm_xor_si128 (*temp3, *temp2);
+}
+
+INLINE static void KEY_256_ASSIST_1(__m128i* temp1, __m128i * temp2)
+{
+    __m128i temp4;
+    *temp2 = _mm_shuffle_epi32(*temp2, 0xff);
+    temp4 = _mm_slli_si128 (*temp1, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp1 = _mm_xor_si128 (*temp1, temp4);
+    *temp1 = _mm_xor_si128 (*temp1, *temp2);
+}
+
+INLINE static void KEY_256_ASSIST_2(__m128i* temp1, __m128i * temp3)
+{
+    __m128i temp2,temp4;
+    temp4 = _mm_aeskeygenassist_si128 (*temp1, 0x0);
+    temp2 = _mm_shuffle_epi32(temp4, 0xaa);
+    temp4 = _mm_slli_si128 (*temp3, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    temp4 = _mm_slli_si128 (temp4, 0x4);
+    *temp3 = _mm_xor_si128 (*temp3, temp4);
+    *temp3 = _mm_xor_si128 (*temp3, temp2);
+}
+
+/*
+ * AES-NI key expansion core
+ */
+static void AES_128_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    key[0] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1 ,0x1);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[1] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x2);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[2] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x4);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[3] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x8);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[4] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x10);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[5] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x20);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[6] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x40);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[7] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x80);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[8] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x1b);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[9] = temp1;
+    temp2 = _mm_aeskeygenassist_si128 (temp1,0x36);
+    temp1 = AES_128_ASSIST(temp1, temp2);
+    key[10] = temp1;
+}
+
+static void AES_192_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2, temp3;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
+    key[0]=temp1;
+    key[1]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x1);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[1] = mm_shuffle_pd_i0(key[1], temp1);
+    key[2] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x2);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[3]=temp1;
+    key[4]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x4);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[4] = mm_shuffle_pd_i0(key[4], temp1);
+    key[5] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x8);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[6]=temp1;
+    key[7]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x10);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[7] = mm_shuffle_pd_i0(key[7], temp1);
+    key[8] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x20);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[9]=temp1;
+    key[10]=temp3;
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x40);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[10] = mm_shuffle_pd_i0(key[10], temp1);
+    key[11] = mm_shuffle_pd_i1(temp1, temp3);
+    temp2=_mm_aeskeygenassist_si128 (temp3,0x80);
+    KEY_192_ASSIST(&temp1, &temp2, &temp3);
+    key[12]=temp1;
+    key[13]=temp3;
+}
+
+static void AES_256_Key_Expansion (unsigned char *userkey, __m128i *key)
+{
+    __m128i temp1, temp2, temp3;
+    temp1 = _mm_loadu_si128((__m128i*)userkey);
+    temp3 = _mm_loadu_si128((__m128i*)(userkey+16));
+    key[0] = temp1;
+    key[1] = temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x01);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[2]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[3]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x02);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[4]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[5]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x04);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[6]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[7]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x08);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[8]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[9]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x10);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[10]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[11]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x20);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[12]=temp1;
+    KEY_256_ASSIST_2(&temp1, &temp3);
+    key[13]=temp3;
+    temp2 = _mm_aeskeygenassist_si128 (temp3,0x40);
+    KEY_256_ASSIST_1(&temp1, &temp2);
+    key[14]=temp1;
+}
+#endif /* COMPILER_SUPPORTS_AES_NI */
+
+/*
+ * SW AES lookup tables
+ */
 static const unsigned char Sbox[256] = {
     0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
     0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
@@ -649,449 +978,512 @@ static const word32 D3[256] = {
 };
 
 /*
- * Common macros in both the encryption and decryption routines.
- */
-#define ADD_ROUND_KEY_4 (block[0]^=*keysched++, block[1]^=*keysched++, \
-		         block[2]^=*keysched++, block[3]^=*keysched++)
-#define ADD_ROUND_KEY_6 (block[0]^=*keysched++, block[1]^=*keysched++, \
-		         block[2]^=*keysched++, block[3]^=*keysched++, \
-		         block[4]^=*keysched++, block[5]^=*keysched++)
-#define ADD_ROUND_KEY_8 (block[0]^=*keysched++, block[1]^=*keysched++, \
-		         block[2]^=*keysched++, block[3]^=*keysched++, \
-		         block[4]^=*keysched++, block[5]^=*keysched++, \
-		         block[6]^=*keysched++, block[7]^=*keysched++)
-#define MOVEWORD(i) ( block[i] = newstate[i] )
-
-/*
- * Macros for the encryption routine. There are three encryption
- * cores, for Nb=4,6,8.
+ * Software AES key expansion macros
  */
-#define MAKEWORD(i) ( newstate[i] = (E0[(block[i] >> 24) & 0xFF] ^ \
-				     E1[(block[(i+C1)%Nb] >> 16) & 0xFF] ^ \
-				     E2[(block[(i+C2)%Nb] >> 8) & 0xFF] ^ \
-				     E3[block[(i+C3)%Nb] & 0xFF]) )
-#define LASTWORD(i) ( newstate[i] = (Sbox[(block[i] >> 24) & 0xFF] << 24) | \
-			    (Sbox[(block[(i+C1)%Nb] >> 16) & 0xFF] << 16) | \
-			    (Sbox[(block[(i+C2)%Nb] >>  8) & 0xFF] <<  8) | \
-			    (Sbox[(block[(i+C3)%Nb]      ) & 0xFF]      ) )
+#define mulby2(x) ( ((x&0x7F) << 1) ^ (x & 0x80 ? 0x1B : 0) )
 
 /*
- * Core encrypt routines, expecting word32 inputs read big-endian
- * from the byte-oriented input stream.
+ * Set up an AESContext. `keylen' is measured in
+ * bytes; it can be either 16 (128-bit), 24 (192-bit), or 32
+ * (256-bit).
  */
-static void aes_encrypt_nb_4(AESContext * ctx, word32 * block)
-{
-    int i;
-    static const int C1 = 1, C2 = 2, C3 = 3, Nb = 4;
-    word32 *keysched = ctx->keysched;
-    word32 newstate[4];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_4;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
-    }
-    ADD_ROUND_KEY_4;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    ADD_ROUND_KEY_4;
-}
-static void aes_encrypt_nb_6(AESContext * ctx, word32 * block)
-{
-    int i;
-    static const int C1 = 1, C2 = 2, C3 = 3, Nb = 6;
-    word32 *keysched = ctx->keysched;
-    word32 newstate[6];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_6;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MAKEWORD(4);
-	MAKEWORD(5);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
-	MOVEWORD(4);
-	MOVEWORD(5);
-    }
-    ADD_ROUND_KEY_6;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    LASTWORD(4);
-    LASTWORD(5);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    MOVEWORD(4);
-    MOVEWORD(5);
-    ADD_ROUND_KEY_6;
-}
-static void aes_encrypt_nb_8(AESContext * ctx, word32 * block)
+static void aes_setup(AESContext * ctx, unsigned char *key, int keylen)
 {
-    int i;
-    static const int C1 = 1, C2 = 3, C3 = 4, Nb = 8;
-    word32 *keysched = ctx->keysched;
-    word32 newstate[8];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_8;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MAKEWORD(4);
-	MAKEWORD(5);
-	MAKEWORD(6);
-	MAKEWORD(7);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
-	MOVEWORD(4);
-	MOVEWORD(5);
-	MOVEWORD(6);
-	MOVEWORD(7);
+    ctx->Nr = 6 + (keylen / 4); /* Number of rounds */
+    ctx->offset = 16 - ((size_t)ctx % 16);
+    ctx->isNI = supports_aes_ni();
+
+    if (ctx->isNI)
+    {
+#ifdef COMPILER_SUPPORTS_AES_NI
+        __m128i *keysched, *invkeysched;
+        keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
+        invkeysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
+
+        ctx->encrypt = &aes_encrypt_cbc_ni;
+        ctx->decrypt = &aes_decrypt_cbc_ni;
+        ctx->sdctr = &aes_sdctr_ni;
+
+        /*
+         * Now do the key setup itself.
+         */
+        switch (keylen)
+        {
+        case 16:
+            AES_128_Key_Expansion (key, keysched);
+            break;
+        case 24:
+            AES_192_Key_Expansion (key, keysched);
+            break;
+        case 32:
+            AES_256_Key_Expansion (key, keysched);
+            break;
+        default:
+            assert(0);
+        }
+
+        /*
+         * Now prepare the modified keys for the inverse cipher.
+         */
+        invkeysched += ctx->Nr;
+        *invkeysched = *keysched;
+        switch (ctx->Nr)
+        {
+        case 14:
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        case 12:
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        case 10:
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+            *(--invkeysched) = _mm_aesimc_si128(*(++keysched));
+        default:
+            *(--invkeysched) = *(++keysched);
+        }
+#else
+        assert(0);
+#endif /* COMPILER_SUPPORTS_AES_NI */
     }
-    ADD_ROUND_KEY_8;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    LASTWORD(4);
-    LASTWORD(5);
-    LASTWORD(6);
-    LASTWORD(7);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    MOVEWORD(4);
-    MOVEWORD(5);
-    MOVEWORD(6);
-    MOVEWORD(7);
-    ADD_ROUND_KEY_8;
-}
+    else {
+        int i, j, Nk, rconst;
+        assert(keylen == 16 || keylen == 24 || keylen == 32);
 
-#undef MAKEWORD
-#undef LASTWORD
+        ctx->encrypt = &aes_encrypt_cbc_sw;
+        ctx->decrypt = &aes_decrypt_cbc_sw;
+        ctx->sdctr = &aes_sdctr_sw;
 
-/*
- * Macros for the decryption routine. There are three decryption
- * cores, for Nb=4,6,8.
- */
-#define MAKEWORD(i) ( newstate[i] = (D0[(block[i] >> 24) & 0xFF] ^ \
-				     D1[(block[(i+C1)%Nb] >> 16) & 0xFF] ^ \
-				     D2[(block[(i+C2)%Nb] >> 8) & 0xFF] ^ \
-				     D3[block[(i+C3)%Nb] & 0xFF]) )
-#define LASTWORD(i) (newstate[i] = (Sboxinv[(block[i] >> 24) & 0xFF] << 24) | \
-			   (Sboxinv[(block[(i+C1)%Nb] >> 16) & 0xFF] << 16) | \
-			   (Sboxinv[(block[(i+C2)%Nb] >>  8) & 0xFF] <<  8) | \
-			   (Sboxinv[(block[(i+C3)%Nb]      ) & 0xFF]      ) )
+        Nk = keylen / 4;
+        rconst = 1;
+        for (i = 0; i < (ctx->Nr + 1) * 4; i++) {
+            if (i < Nk)
+                ctx->keysched[i] = GET_32BIT_MSB_FIRST(key + 4 * i);
+            else {
+                word32 temp = ctx->keysched[i - 1];
+                if (i % Nk == 0) {
+                    int a, b, c, d;
+                    a = (temp >> 16) & 0xFF;
+                    b = (temp >> 8) & 0xFF;
+                    c = (temp >> 0) & 0xFF;
+                    d = (temp >> 24) & 0xFF;
+                    temp = Sbox[a] ^ rconst;
+                    temp = (temp << 8) | Sbox[b];
+                    temp = (temp << 8) | Sbox[c];
+                    temp = (temp << 8) | Sbox[d];
+                    rconst = mulby2(rconst);
+                } else if (i % Nk == 4 && Nk > 6) {
+                    int a, b, c, d;
+                    a = (temp >> 24) & 0xFF;
+                    b = (temp >> 16) & 0xFF;
+                    c = (temp >> 8) & 0xFF;
+                    d = (temp >> 0) & 0xFF;
+                    temp = Sbox[a];
+                    temp = (temp << 8) | Sbox[b];
+                    temp = (temp << 8) | Sbox[c];
+                    temp = (temp << 8) | Sbox[d];
+                }
+                ctx->keysched[i] = ctx->keysched[i - Nk] ^ temp;
+            }
+        }
 
+        /*
+         * Now prepare the modified keys for the inverse cipher.
+         */
+        for (i = 0; i <= ctx->Nr; i++) {
+            for (j = 0; j < 4; j++) {
+                word32 temp;
+                temp = ctx->keysched[(ctx->Nr - i) * 4 + j];
+                if (i != 0 && i != ctx->Nr) {
+                    /*
+                     * Perform the InvMixColumn operation on i. The D
+                     * tables give the result of InvMixColumn applied
+                     * to Sboxinv on individual bytes, so we should
+                     * compose Sbox with the D tables for this.
+                     */
+                    int a, b, c, d;
+                    a = (temp >> 24) & 0xFF;
+                    b = (temp >> 16) & 0xFF;
+                    c = (temp >> 8) & 0xFF;
+                    d = (temp >> 0) & 0xFF;
+                    temp = D0[Sbox[a]];
+                    temp ^= D1[Sbox[b]];
+                    temp ^= D2[Sbox[c]];
+                    temp ^= D3[Sbox[d]];
+                }
+                ctx->invkeysched[i * 4 + j] = temp;
+            }
+        }
+    }
+}
+
+#ifdef COMPILER_SUPPORTS_AES_NI
 /*
- * Core decrypt routines, expecting word32 inputs read big-endian
- * from the byte-oriented input stream.
+ * AES-NI encrypt/dectypt core
  */
-static void aes_decrypt_nb_4(AESContext * ctx, word32 * block)
+static void aes_encrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
 {
-    int i;
-    static const int C1 = 4 - 1, C2 = 4 - 2, C3 = 4 - 3, Nb = 4;
-    word32 *keysched = ctx->invkeysched;
-    word32 newstate[4];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_4;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
+    __m128i enc;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
+
+    assert((len & 15) == 0);
+
+    /* Load IV */
+    enc = _mm_loadu_si128((__m128i*)(ctx->iv));
+    while (block < finish)
+    {
+        /* Key schedule ptr   */
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);
+
+        /* Xor data with IV */
+        enc  = _mm_xor_si128(_mm_loadu_si128(block), enc);
+
+        /* Perform rounds */
+        enc  = _mm_xor_si128(enc, *keysched);
+        switch (ctx->Nr)
+        {
+        case 14:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 12:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 10:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenclast_si128(enc, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Store and go to next block */
+        _mm_storeu_si128(block, enc);
+        ++block;
     }
-    ADD_ROUND_KEY_4;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    ADD_ROUND_KEY_4;
+
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)(ctx->iv), enc);
 }
-static void aes_decrypt_nb_6(AESContext * ctx, word32 * block)
+
+static void aes_decrypt_cbc_ni(unsigned char *blk, int len, AESContext * ctx)
 {
-    int i;
-    static const int C1 = 6 - 1, C2 = 6 - 2, C3 = 6 - 3, Nb = 6;
-    word32 *keysched = ctx->invkeysched;
-    word32 newstate[6];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_6;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MAKEWORD(4);
-	MAKEWORD(5);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
-	MOVEWORD(4);
-	MOVEWORD(5);
+    __m128i dec, last, iv;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
+
+    assert((len & 15) == 0);
+
+    /* Load IV */
+    iv = _mm_loadu_si128((__m128i*)(ctx->iv));
+    while (block < finish)
+    {
+        /* Key schedule ptr   */
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->invkeysched + ctx->offset);
+        last = _mm_loadu_si128(block);
+        dec  = _mm_xor_si128(last, *keysched);
+        switch (ctx->Nr)
+        {
+        case 14:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+        case 12:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+        case 10:
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdec_si128(dec, *(++keysched));
+            dec = _mm_aesdeclast_si128(dec, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Xor data with IV */
+        dec  = _mm_xor_si128(iv, dec);
+
+        /* Store data */
+        _mm_storeu_si128(block, dec);
+        iv = last;
+
+        /* Go to next block */
+        ++block;
     }
-    ADD_ROUND_KEY_6;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    LASTWORD(4);
-    LASTWORD(5);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    MOVEWORD(4);
-    MOVEWORD(5);
-    ADD_ROUND_KEY_6;
+
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)(ctx->iv), dec);
 }
-static void aes_decrypt_nb_8(AESContext * ctx, word32 * block)
+
+static void aes_sdctr_ni(unsigned char *blk, int len, AESContext *ctx)
 {
-    int i;
-    static const int C1 = 8 - 1, C2 = 8 - 3, C3 = 8 - 4, Nb = 8;
-    word32 *keysched = ctx->invkeysched;
-    word32 newstate[8];
-    for (i = 0; i < ctx->Nr - 1; i++) {
-	ADD_ROUND_KEY_8;
-	MAKEWORD(0);
-	MAKEWORD(1);
-	MAKEWORD(2);
-	MAKEWORD(3);
-	MAKEWORD(4);
-	MAKEWORD(5);
-	MAKEWORD(6);
-	MAKEWORD(7);
-	MOVEWORD(0);
-	MOVEWORD(1);
-	MOVEWORD(2);
-	MOVEWORD(3);
-	MOVEWORD(4);
-	MOVEWORD(5);
-	MOVEWORD(6);
-	MOVEWORD(7);
-    }
-    ADD_ROUND_KEY_8;
-    LASTWORD(0);
-    LASTWORD(1);
-    LASTWORD(2);
-    LASTWORD(3);
-    LASTWORD(4);
-    LASTWORD(5);
-    LASTWORD(6);
-    LASTWORD(7);
-    MOVEWORD(0);
-    MOVEWORD(1);
-    MOVEWORD(2);
-    MOVEWORD(3);
-    MOVEWORD(4);
-    MOVEWORD(5);
-    MOVEWORD(6);
-    MOVEWORD(7);
-    ADD_ROUND_KEY_8;
-}
+    const __m128i BSWAP_EPI64 = _mm_setr_epi8(3,2,1,0,7,6,5,4,11,10,9,8,15,14,13,12);
+    const __m128i ONE  = _mm_setr_epi32(0,0,0,1);
+    const __m128i ZERO = _mm_setzero_si128();
+    __m128i iv;
+    __m128i* block = (__m128i*)blk;
+    const __m128i* finish = (__m128i*)(blk + len);
 
-#undef MAKEWORD
-#undef LASTWORD
+    assert((len & 15) == 0);
 
+    iv = _mm_loadu_si128((__m128i*)ctx->iv);
 
-/*
- * Set up an AESContext. `keylen' and `blocklen' are measured in
- * bytes; each can be either 16 (128-bit), 24 (192-bit), or 32
- * (256-bit).
- */
-static void aes_setup(AESContext * ctx, int blocklen,
-	       unsigned char *key, int keylen)
-{
-    int i, j, Nk, rconst;
-
-    assert(blocklen == 16 || blocklen == 24 || blocklen == 32);
-    assert(keylen == 16 || keylen == 24 || keylen == 32);
-
-    /*
-     * Basic parameters. Words per block, words in key, rounds.
-     */
-    Nk = keylen / 4;
-    ctx->Nb = blocklen / 4;
-    ctx->Nr = 6 + (ctx->Nb > Nk ? ctx->Nb : Nk);
-
-    /*
-     * Assign core-function pointers.
-     */
-    if (ctx->Nb == 8)
-	ctx->encrypt = aes_encrypt_nb_8, ctx->decrypt = aes_decrypt_nb_8;
-    else if (ctx->Nb == 6)
-	ctx->encrypt = aes_encrypt_nb_6, ctx->decrypt = aes_decrypt_nb_6;
-    else if (ctx->Nb == 4)
-	ctx->encrypt = aes_encrypt_nb_4, ctx->decrypt = aes_decrypt_nb_4;
-
-    /*
-     * Now do the key setup itself.
-     */
-    rconst = 1;
-    for (i = 0; i < (ctx->Nr + 1) * ctx->Nb; i++) {
-	if (i < Nk)
-	    ctx->keysched[i] = GET_32BIT_MSB_FIRST(key + 4 * i);
-	else {
-	    word32 temp = ctx->keysched[i - 1];
-	    if (i % Nk == 0) {
-		int a, b, c, d;
-		a = (temp >> 16) & 0xFF;
-		b = (temp >> 8) & 0xFF;
-		c = (temp >> 0) & 0xFF;
-		d = (temp >> 24) & 0xFF;
-		temp = Sbox[a] ^ rconst;
-		temp = (temp << 8) | Sbox[b];
-		temp = (temp << 8) | Sbox[c];
-		temp = (temp << 8) | Sbox[d];
-		rconst = mulby2(rconst);
-	    } else if (i % Nk == 4 && Nk > 6) {
-		int a, b, c, d;
-		a = (temp >> 24) & 0xFF;
-		b = (temp >> 16) & 0xFF;
-		c = (temp >> 8) & 0xFF;
-		d = (temp >> 0) & 0xFF;
-		temp = Sbox[a];
-		temp = (temp << 8) | Sbox[b];
-		temp = (temp << 8) | Sbox[c];
-		temp = (temp << 8) | Sbox[d];
-	    }
-	    ctx->keysched[i] = ctx->keysched[i - Nk] ^ temp;
-	}
-    }
+    while (block < finish)
+    {
+        __m128i enc;
+        __m128i* keysched = (__m128i*)((unsigned char*)ctx->keysched + ctx->offset);/* Key schedule ptr   */
+
+        /* Perform rounds */
+        enc  = _mm_xor_si128(iv, *keysched); /* Note that we use IV */
+        switch (ctx->Nr)
+        {
+        case 14:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 12:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+        case 10:
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenc_si128(enc, *(++keysched));
+            enc = _mm_aesenclast_si128(enc, *(++keysched));
+            break;
+        default:
+            assert(0);
+        }
+
+        /* Xor with block and store result */
+        enc = _mm_xor_si128(enc, _mm_loadu_si128(block));
+        _mm_storeu_si128(block, enc);
 
-    /*
-     * Now prepare the modified keys for the inverse cipher.
-     */
-    for (i = 0; i <= ctx->Nr; i++) {
-	for (j = 0; j < ctx->Nb; j++) {
-	    word32 temp;
-	    temp = ctx->keysched[(ctx->Nr - i) * ctx->Nb + j];
-	    if (i != 0 && i != ctx->Nr) {
-		/*
-		 * Perform the InvMixColumn operation on i. The D
-		 * tables give the result of InvMixColumn applied
-		 * to Sboxinv on individual bytes, so we should
-		 * compose Sbox with the D tables for this.
-		 */
-		int a, b, c, d;
-		a = (temp >> 24) & 0xFF;
-		b = (temp >> 16) & 0xFF;
-		c = (temp >> 8) & 0xFF;
-		d = (temp >> 0) & 0xFF;
-		temp = D0[Sbox[a]];
-		temp ^= D1[Sbox[b]];
-		temp ^= D2[Sbox[c]];
-		temp ^= D3[Sbox[d]];
-	    }
-	    ctx->invkeysched[i * ctx->Nb + j] = temp;
-	}
+        /* Increment of IV */
+        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap endianess     */
+        iv  = _mm_add_epi64(iv, ONE);            /* Inc low part       */
+        enc = _mm_cmpeq_epi64(iv, ZERO);         /* Check for carry    */
+        enc = _mm_unpacklo_epi64(ZERO, enc);     /* Pack carry reg     */
+        iv  = _mm_sub_epi64(iv, enc);            /* Sub carry reg      */
+        iv  = _mm_shuffle_epi8(iv, BSWAP_EPI64); /* Swap enianess back */
+
+        /* Go to next block */
+        ++block;
     }
-}
 
-static void aes_encrypt(AESContext * ctx, word32 * block)
-{
-    ctx->encrypt(ctx, block);
+    /* Update IV */
+    _mm_storeu_si128((__m128i*)ctx->iv, iv);
 }
+#endif /* COMPILER_SUPPORTS_AES_NI */
 
-static void aes_decrypt(AESContext * ctx, word32 * block)
-{
-    ctx->decrypt(ctx, block);
-}
+/*
+ * Software encrypt/decrypt macros
+ */
+#define ADD_ROUND_KEY (block[0]^=*keysched++,\
+                       block[1]^=*keysched++,\
+                       block[2]^=*keysched++,\
+                       block[3]^=*keysched++)
+#define MOVEWORD(i) ( block[i] = newstate[i] )
+
+#define ENCWORD(i) ( newstate[i] = (E0[(block[i      ] >> 24) & 0xFF] ^ \
+                                    E1[(block[(i+1)&3] >> 16) & 0xFF] ^ \
+                                    E2[(block[(i+2)&3] >>  8) & 0xFF] ^ \
+                                    E3[ block[(i+3)&3]        & 0xFF]) )
+#define ENCROUND { ENCWORD(0); ENCWORD(1); ENCWORD(2); ENCWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
 
-static void aes_encrypt_cbc(unsigned char *blk, int len, AESContext * ctx)
+#define ENCLASTWORD(i) ( newstate[i] = \
+                            (Sbox[(block[i]       >> 24) & 0xFF] << 24) | \
+                            (Sbox[(block[(i+1)&3] >> 16) & 0xFF] << 16) | \
+                            (Sbox[(block[(i+2)&3] >>  8) & 0xFF] <<  8) | \
+                            (Sbox[(block[(i+3)&3]      ) & 0xFF]      ) )
+#define ENCLASTROUND { ENCLASTWORD(0); ENCLASTWORD(1); ENCLASTWORD(2); ENCLASTWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
+
+#define DECWORD(i) ( newstate[i] =  (D0[(block[i]       >> 24) & 0xFF] ^ \
+                                     D1[(block[(i+3)&3] >> 16) & 0xFF] ^ \
+                                     D2[(block[(i+2)&3] >> 8)  & 0xFF] ^ \
+                                     D3[ block[(i+1)&3]        & 0xFF]) )
+#define DECROUND { DECWORD(0); DECWORD(1); DECWORD(2); DECWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
+
+#define DECLASTWORD(i) (newstate[i] = \
+                           (Sboxinv[(block[i]       >> 24) & 0xFF] << 24) | \
+                           (Sboxinv[(block[(i+3)&3] >> 16) & 0xFF] << 16) | \
+                           (Sboxinv[(block[(i+2)&3] >>  8) & 0xFF] <<  8) | \
+                           (Sboxinv[(block[(i+1)&3]      ) & 0xFF]      ) )
+#define DECLASTROUND { DECLASTWORD(0); DECLASTWORD(1); DECLASTWORD(2); DECLASTWORD(3); \
+                   MOVEWORD(0); MOVEWORD(1); MOVEWORD(2); MOVEWORD(3); ADD_ROUND_KEY; }
+
+/*
+ * Software AES encrypt/dectypt core
+ */
+static void aes_encrypt_cbc_sw(unsigned char *blk, int len, AESContext * ctx)
 {
-    word32 iv[4];
+    word32 block[4];
+    unsigned char* finish = blk + len;
     int i;
 
     assert((len & 15) == 0);
 
-    memcpy(iv, ctx->iv, sizeof(iv));
+    memcpy(block, ctx->iv, sizeof(block));
 
-    while (len > 0) {
-	for (i = 0; i < 4; i++)
-	    iv[i] ^= GET_32BIT_MSB_FIRST(blk + 4 * i);
-	aes_encrypt(ctx, iv);
-	for (i = 0; i < 4; i++)
-	    PUT_32BIT_MSB_FIRST(blk + 4 * i, iv[i]);
-	blk += 16;
-	len -= 16;
+    while (blk < finish) {
+        word32 *keysched = ctx->keysched;
+        word32 newstate[4];
+        for (i = 0; i < 4; i++)
+            block[i] ^= GET_32BIT_MSB_FIRST(blk + 4 * i);
+        ADD_ROUND_KEY;
+        switch (ctx->Nr)
+        {
+        case 14:
+            ENCROUND;
+            ENCROUND;
+        case 12:
+            ENCROUND;
+            ENCROUND;
+        case 10:
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCLASTROUND;
+            break;
+        default:
+            assert(0);
+        }
+        for (i = 0; i < 4; i++)
+            PUT_32BIT_MSB_FIRST(blk + 4 * i, block[i]);
+        blk += 16;
     }
 
-    memcpy(ctx->iv, iv, sizeof(iv));
+    memcpy(ctx->iv, block, sizeof(block));
 }
 
-static void aes_decrypt_cbc(unsigned char *blk, int len, AESContext * ctx)
+static void aes_sdctr_sw(unsigned char *blk, int len, AESContext *ctx)
 {
-    word32 iv[4], x[4], ct[4];
+    word32 iv[4];
+    unsigned char* finish = blk + len;
     int i;
 
     assert((len & 15) == 0);
 
     memcpy(iv, ctx->iv, sizeof(iv));
 
-    while (len > 0) {
-	for (i = 0; i < 4; i++)
-	    x[i] = ct[i] = GET_32BIT_MSB_FIRST(blk + 4 * i);
-	aes_decrypt(ctx, x);
-	for (i = 0; i < 4; i++) {
-	    PUT_32BIT_MSB_FIRST(blk + 4 * i, iv[i] ^ x[i]);
-	    iv[i] = ct[i];
-	}
-	blk += 16;
-	len -= 16;
+    while (blk < finish) {
+        word32 *keysched = ctx->keysched;
+        word32 newstate[4], block[4], tmp;
+        memcpy(block, iv, sizeof(block));
+        ADD_ROUND_KEY;
+        switch (ctx->Nr)
+        {
+        case 14:
+            ENCROUND;
+            ENCROUND;
+        case 12:
+            ENCROUND;
+            ENCROUND;
+        case 10:
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCROUND;
+            ENCLASTROUND;
+            break;
+        default:
+            assert(0);
+        }
+        for (i = 0; i < 4; i++) {
+            tmp = GET_32BIT_MSB_FIRST(blk + 4 * i);
+            PUT_32BIT_MSB_FIRST(blk + 4 * i, tmp ^ block[i]);
+        }
+        for (i = 3; i >= 0; i--)
+            if ((iv[i] = (iv[i] + 1) & 0xffffffff) != 0)
+                break;
+        blk += 16;
     }
 
     memcpy(ctx->iv, iv, sizeof(iv));
 }
 
-static void aes_sdctr(unsigned char *blk, int len, AESContext *ctx)
+static void aes_decrypt_cbc_sw(unsigned char *blk, int len, AESContext * ctx)
 {
-    word32 iv[4], b[4], tmp;
+    word32 iv[4];
+    unsigned char* finish = blk + len;
     int i;
 
     assert((len & 15) == 0);
 
     memcpy(iv, ctx->iv, sizeof(iv));
 
-    while (len > 0) {
-	memcpy(b, iv, sizeof(b));
-	aes_encrypt(ctx, b);
-	for (i = 0; i < 4; i++) {
-	    tmp = GET_32BIT_MSB_FIRST(blk + 4 * i);
-	    PUT_32BIT_MSB_FIRST(blk + 4 * i, tmp ^ b[i]);
-	}
-	for (i = 3; i >= 0; i--)
-	    if ((iv[i] = (iv[i] + 1) & 0xffffffff) != 0)
-		break;
-	blk += 16;
-	len -= 16;
+    while (blk < finish) {
+        word32 *keysched = ctx->invkeysched;
+        word32 newstate[4], ct[4], block[4];
+        for (i = 0; i < 4; i++)
+            block[i] = ct[i] = GET_32BIT_MSB_FIRST(blk + 4 * i);
+        ADD_ROUND_KEY;
+        switch (ctx->Nr)
+        {
+        case 14:
+            DECROUND;
+            DECROUND;
+        case 12:
+            DECROUND;
+            DECROUND;
+        case 10:
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECROUND;
+            DECLASTROUND;
+            break;
+        default:
+            assert(0);
+        }
+        for (i = 0; i < 4; i++) {
+            PUT_32BIT_MSB_FIRST(blk + 4 * i, iv[i] ^ block[i]);
+            iv[i] = ct[i];
+        }
+        blk += 16;
     }
 
     memcpy(ctx->iv, iv, sizeof(iv));
@@ -1110,27 +1502,32 @@ void aes_free_context(void *handle)
 void aes128_key(void *handle, unsigned char *key)
 {
     AESContext *ctx = (AESContext *)handle;
-    aes_setup(ctx, 16, key, 16);
+    aes_setup(ctx, key, 16);
 }
 
 void aes192_key(void *handle, unsigned char *key)
 {
     AESContext *ctx = (AESContext *)handle;
-    aes_setup(ctx, 16, key, 24);
+    aes_setup(ctx, key, 24);
 }
 
 void aes256_key(void *handle, unsigned char *key)
 {
     AESContext *ctx = (AESContext *)handle;
-    aes_setup(ctx, 16, key, 32);
+    aes_setup(ctx, key, 32);
 }
 
 void aes_iv(void *handle, unsigned char *iv)
 {
     AESContext *ctx = (AESContext *)handle;
-    int i;
-    for (i = 0; i < 4; i++)
-	ctx->iv[i] = GET_32BIT_MSB_FIRST(iv + 4 * i);
+    if (ctx->isNI) {
+        memcpy(ctx->iv, iv, sizeof(ctx->iv));
+    }
+    else {
+        int i;
+        for (i = 0; i < 4; i++)
+            ctx->iv[i] = GET_32BIT_MSB_FIRST(iv + 4 * i);
+    }
 }
 
 void aes_ssh2_encrypt_blk(void *handle, unsigned char *blk, int len)
@@ -1154,7 +1551,7 @@ static void aes_ssh2_sdctr(void *handle, unsigned char *blk, int len)
 void aes256_encrypt_pubkey(unsigned char *key, unsigned char *blk, int len)
 {
     AESContext ctx;
-    aes_setup(&ctx, 16, key, 32);
+    aes_setup(&ctx, key, 32);
     memset(ctx.iv, 0, sizeof(ctx.iv));
     aes_encrypt_cbc(blk, len, &ctx);
     smemclr(&ctx, sizeof(ctx));
@@ -1163,7 +1560,7 @@ void aes256_encrypt_pubkey(unsigned char *key, unsigned char *blk, int len)
 void aes256_decrypt_pubkey(unsigned char *key, unsigned char *blk, int len)
 {
     AESContext ctx;
-    aes_setup(&ctx, 16, key, 32);
+    aes_setup(&ctx, key, 32);
     memset(ctx.iv, 0, sizeof(ctx.iv));
     aes_decrypt_cbc(blk, len, &ctx);
     smemclr(&ctx, sizeof(ctx));
-- 
2.5.3.windows.1

